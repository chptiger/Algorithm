package DP;

/**
 * 
 * 0-1添加物品时是从体积大的容器到体积小的容器添加的，这样就可以避免同一种物品重复使用了，
 * 而完全背包则是从体积小的背包开始到大的背包。其他地方和0-1背包就一样了。
 * 
 * 
 * 完全背包是在N种物品中选取若干件（同一种物品可多次选取）放在空间为V的背包里，每种物品的体积为C1，C2，…，Cn，与之相对应的价值为W1,W2，…， * Wn. 
 * 求解怎么装物品可使背包里物品总价值最大。
 *
 * 动态规划（DP）： 
 * 1） 子问题定义：F[i][j]表示前i种物品中选取若干件物品放入剩余空间为j的背包中所能得到的最大价值。
 * 2） 根据第i种物品放多少件进行决策 
 * 
 * F[i][j]=max{ F [ i-1 ][ j - K*C[i]] + K*W[i] } , 0<= K*C[i] <= j
 * 
 * 其中F[i-1][j-K*C[i]]+K*W[i]表示前i-1种物品中选取若干件物品放入剩余空间为j-K*C[i]
 * 的背包中所能得到的最大价值加上k件第i种物品；
 * 
 * 设物品种数为N，背包容量为V，第i种物品体积为C[i]，第i种物品价值为W[i]。
 * 与01背包相同，完全背包也需要求出NV个状态F[i][j]。但是完全背包求F[i][j]时需要对k分别取0,…，j/C[i]求最大F[i][j]值,
 * 耗时为j/C[i]。 那么总的时间复杂度为O(NV∑(j/C[i]))
 * 
 */
public class Knapsack_Unbounded {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
